컴퓨터에서 실수를 표현하는 방법은 **고정 소수점**과 **부동 소수점** 두 가지 방식이 존재한다.

## 1. 고정 소수점(Fixed Point)

소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식(정수 + 소수)

```
-3.141592는 부호(-)와 정수부(3), 소수부(0.141592) 3가지 요소 필요함
```

<img src="고정소수점과 부동소수점.assets/image-20220810184703496.png" alt="image-20220810184703496" style="zoom:50%;" />

**장점** : 실수를 정수부와 소수부로 표현하여 단순하다.

**단점** : 표현의 범위가 너무 적어서 활용하기 힘들다. (정수부는 15bit, 소수부는 16bit)

## 2. **부동 소수점(Floating Point)**

> 실수를 가수부 + 지수부로 표현한다.
>
> - 가수 : 실수의 실제값 표현
> - 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄

**지수의 값에 따라 소수점이 움직이는 방식**을 활용한 실수 표현 방법이다.

즉, 소수점의 위치가 고정되어 있지 않는다.

![http://tcpschool.com/lectures/img_c_floating_point_32.png](고정소수점과 부동소수점.assets/img_c_floating_point_32.png)

**장점** : 표현할 수 있는 수의 범위가 넓어진다. (현재 대부분 시스템에서 활용 중)

**단점** : 오차가 발생할 수 있다. (부동소수점으로 표현할 수 있는 방법이 매우 다양함)

### 변환 방법

```
-12.31을 부동소수점 32비트에서 표현
```

1. **이진수 변환**

   1. 정수부 : 1100(2)
   2. 소수부: 0.31 = 0.010011..........(2)

   -12.31은 -1100.010011.............(2)가 된다

2. **정규화**

   1.xxx형태로 정규화한다

   -1.100010011.............* 2^3

   `부호: 1 (음수)`

   `지수부: 3` → 지수부는 바이어스 값(127) 더해줘야 함. → 127+3 = 130 ⇒ 이진수로 변환시 `10000010`

   `가수부 : 10000010`

3. 정형화

   부호 지수 가수로 정형화

   `11000001010000010`



### 더 알아보기

**지수부는 왜 바이어스가 127인가?**

일단 두 가지 이유가 있다.

**첫 번째가 Infinity와 NaNs 문제이다.**

float의 지수부가 최대 영역보다 커지면 더 이상 표현할 수 없기때문에

overflow가 일어난다. 그래서 최대 지수값인 255에서 11111111(2)를

overflow 처리를 위해 사용한다.

그리고 에러처리를 위해 NaNs(not a number)를 정의하여 처리한다.

**두 번째가 gradual underflow 문제이다.**

0에 가까운 값이 나올때 지수부는 1.x 형태로 정규화하기 위해서

소숫점을 당기는데 이 당기다보면 지수의 음수 값이 계속 작아져

지수부의 음수표현 범위를 초과한다.

그래서 더 이상 정확도를 책정할 수 없고 점진적 언더플로우 처리를 하여

값을 0을 만든다.

그래서 최저 지수값인 0인 00000000(2)을 언더플로우를 처리하여

0.000000(float기준) 값을 가진다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97c1b263-4e8b-4a49-9a18-ef2a483e35c6/Untitled.png)

**바이어스?**

0~255까지기때문에 0과 255를 제외하고

1~254까지 출력한다고 가정하고 가운데 값이 127이 가운데 값이 되기떄문에

바이어스가 되는 것이다.

### 참고

https://codetorial.net/articles/floating_point.html

https://hmjo.tistory.com/85